/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package vcenter_tag_factory

import (
	"context"
	"crypto/sha256"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"testing"
	"time"

	"github.com/GoogleCloudPlatform/cloud-foundation-toolkit/infra/blueprint-test/pkg/tft"
	"github.com/stretchr/testify/assert"
	"github.com/vmware/govmomi"
	"github.com/vmware/govmomi/session/cache"
	"github.com/vmware/govmomi/session/keepalive"
	"github.com/vmware/govmomi/vapi/rest"
	"github.com/vmware/govmomi/vapi/tags"
)

const DefaultAPITimeout = time.Minute * 5

// Client is the client connection manager for the vSphere provider. It
// holds the connections to the various API endpoints we need to interface
// with, such as the VMODL API through govmomi, and the REST SDK through
// alternate libraries.
type Client struct {
	// The VIM/govmomi client.
	vimClient *govmomi.Client

	// The REST client used for tags and content library.
	restClient *rest.Client
}

// Config holds the provider configuration, and delivers a populated
// VSphereClient based off the contained settings.
type Config struct {
	InsecureFlag    bool
	User            string
	Password        string
	VSphereServer   string
	KeepAlive       int
	RestSessionPath string
	Persist         bool
	VimSessionPath  string
}

// NewConfig returns a new Config from a supplied ResourceData.
func NewConfig(user, password, server string, insecure bool) (*Config, error) {

	c := &Config{
		User:          user,
		Password:      password,
		InsecureFlag:  insecure,
		VSphereServer: server,
	}

	return c, nil
}

// Client returns a new client for accessing VMWare vSphere.
func (c *Config) Client() (*Client, error) {
	client := new(Client)

	s := new(cache.Session)
	s, err := c.restURL()
	if err != nil {
		return nil, err
	}
	client.restClient, err = c.SavedRestSessionOrNew(s)
	if err != nil {
		return nil, err
	}

	return client, nil
}

func (c *Config) restURL() (*cache.Session, error) {
	u, err := url.Parse("https://" + c.VSphereServer)
	if err != nil {
		return nil, err
	}
	u.User = url.UserPassword(c.User, c.Password)
	s := &cache.Session{
		URL:      u,
		Insecure: c.InsecureFlag,
	}
	return s, err
}

func (c *Config) SavedRestSessionOrNew(s *cache.Session) (*rest.Client, error) {
	log.Printf("[DEBUG] Setting up REST client")
	ctx, cancel := context.WithTimeout(context.Background(), DefaultAPITimeout)
	defer cancel()

	s.DirREST = c.RestSessionPath
	s.Passthrough = !c.Persist
	restClient := new(rest.Client)
	err := s.Login(ctx, restClient, nil)
	if err != nil {
		return nil, err
	}
	// Setup keepalive functionality
	var f func() error
	t := keepalive.NewHandlerREST(restClient, time.Duration(c.KeepAlive)*time.Minute, f)
	t.Start()
	restClient.Transport = t

	log.Println("[DEBUG] CIS REST client configuration successful")
	return restClient, nil
}

// vimURL returns a URL to pass to the VIM SOAP client.
func (c *Config) vimURL() (*url.URL, error) {
	u, err := url.Parse("https://" + c.VSphereServer + "/sdk")
	if err != nil {
		return nil, fmt.Errorf("Error parse url: %s", err)
	}

	u.User = url.UserPassword(c.User, c.Password)

	return u, nil
}

func (c *Config) vimURLWithoutPassword() (*url.URL, error) {
	u, err := c.vimURL()
	if err != nil {
		return nil, err
	}
	withoutCredentials := u
	withoutCredentials.User = url.User(u.User.Username())
	return withoutCredentials, nil
}

// sessionFile is a helper that generates a unique hash of the client's URL
// to use as the session file name.
//
// This is the same logic used as part of govmomi and is designed to be
// consistent so that sessions can be shared if possible between both tools.
func (c *Config) sessionFile() (string, error) {
	u, err := c.vimURLWithoutPassword()
	if err != nil {
		return "", err
	}

	// Key session file off of full URI and insecure setting.
	// Hash key to get a predictable, canonical format.
	key := fmt.Sprintf("%s#insecure=%t", u.String(), c.InsecureFlag)
	name := fmt.Sprintf("%040x", sha256.Sum256([]byte(key)))
	return name, nil
}

// restSessionFile is takes the session file name generated by sessionFile and
// then prefixes the REST client session path to it.
func (c *Config) restSessionFile() (string, error) {
	p, err := c.sessionFile()
	if err != nil {
		return "", err
	}
	return filepath.Join(c.RestSessionPath, p), nil
}

func restSessionValid(client *rest.Client) bool {
	sessionURL := client.URL().String() + "/com/vmware/cis/session?~action=get"
	resp, err := client.Post(sessionURL, "", nil)
	if err != nil || resp.StatusCode != 200 {
		return false
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	return true
}
func readRestSession(path string) (string, error) {
	f, err := os.Open(path)
	if err != nil {
		if os.IsNotExist(err) {
			// No session file exists
			log.Printf("[DEBUG] No REST session file exists.")
			return "", nil
		}
		return "", err
	}

	a, err := f.Stat()
	if err != nil {
		return "", err
	}
	c := make([]byte, a.Size())
	_, err = f.Read(c)
	if err != nil {
		return "", err
	}
	return string(c), nil
}
func (c *Config) LoadAndVerifyRestSession(client *govmomi.Client) (*rest.Client, bool, error) {
	// Connect to the CIS REST endpoint for tagging, or load a previous session
	restClient := rest.NewClient(client.Client)
	cookiePath, _ := url.Parse("/rest/com/vmware")
	cookiePath.Scheme = client.URL().Scheme
	cookiePath.Host = client.URL().Host
	cookies := client.Jar.Cookies(cookiePath)
	if c.Persist {
		log.Printf("[DEBUG] Session persistence is enabled. Attempting to use existion session")
		restSessionFile, err := c.restSessionFile()
		if err != nil {
			return nil, false, err
		}
		sessionID, err := readRestSession(restSessionFile)
		if err != nil {
			return nil, false, err
		}
		if sessionID != "" {
			newcookie := http.Cookie{
				Name:  "vmware-api-session-id",
				Value: sessionID,
			}
			restClient = rest.NewClient(client.Client)
			restClient.Jar.SetCookies(cookiePath, append(cookies, &newcookie))
		}
	}
	if restSessionValid(restClient) {
		log.Printf("[DEBUG] Existing REST session still active")
		return restClient, true, nil
	}
	// Existing REST session is no longer valid. Reset the rest cookie.
	log.Printf("[DEBUG] Existing REST session has expired")
	newcookie := http.Cookie{
		Name:   "vmware-api-session-id",
		Value:  "",
		MaxAge: -1,
	}
	restClient.Jar.SetCookies(cookiePath, []*http.Cookie{&newcookie})
	return restClient, false, nil
}

func TestVcenterTagFactory(t *testing.T) {
	insecure, _ := strconv.ParseBool(os.Getenv("VSPHERE_ALLOW_UNVERIFIED_SSL"))
	username := os.Getenv("VSPHERE_USER")
	password := os.Getenv("VSPHERE_PASSWORD")
	host := os.Getenv("VSPHERE_SERVER")
	projects_backend_bucket := os.Getenv("TF_BACKEND_BUCKET")

	backendConfig := map[string]interface{}{
		"bucket": projects_backend_bucket,
	}

	c, err := NewConfig(username, password, host, insecure)
	if err != nil {
		panic(err)
	}
	vclient, _ := c.Client()
	restClient := vclient.restClient

	bpt := tft.NewTFBlueprintTest(t,
		tft.WithBackendConfig(backendConfig),
	)

	bpt.DefineVerify(func(assert *assert.Assertions) {

		bpt.DefaultVerify(assert)
		vcenter_tag_cat_name := "cft-test-tag-category"
		vcenter_tag_cat_cardinality := "MULTIPLE"
		vcenter_tag_cat_assoc_types := []string{"Folder", "VirtualMachine"}
		vcenter_tag_name := "cft-test-tag1"
		tf_tag_category_id := bpt.GetStringOutput("tag_category")
		tf_tag_id := bpt.GetStringOutput("tags")
		tm := tags.NewManager(restClient)
		ctx, cancel := context.WithTimeout(context.Background(), DefaultAPITimeout)
		defer cancel()
		var tagCat tags.Category
		categories, _ := tm.GetCategories(ctx)
		for _, v := range categories {
			if v.ID == tf_tag_category_id {
				tagCat = v

			}
		}
		tl, _ := tm.ListTags(ctx)
		var tag *tags.Tag
		for _, v := range tl {
			each_tag, _ := tm.GetTag(ctx, v)
			if each_tag.Name == vcenter_tag_name {
				tag = each_tag
			}
		}
		assert.Equal(vcenter_tag_cat_name, tagCat.Name, "should have the right Folder Name")
		assert.Equal(vcenter_tag_cat_cardinality, tagCat.Cardinality, "should have the right Folder Type")
		assert.Equal(vcenter_tag_cat_assoc_types, tagCat.AssociableTypes, "should have the right Permssion Paramter Group")
		assert.Equal(tf_tag_id, tag.ID, "should have the right Tag ID")
	})

	bpt.Test()
}
